"""
Plugin for uploading output files to S3 "progressively," meaning to upload each task's output files
immediately upon task completion, instead of waiting for the whole workflow to finish. (The latter
technique, which doesn't need a plugin at all, is illustrated in ../upload_output_files.sh)

To enable, install this plugin (`pip3 install .` & confirm listed by `miniwdl --version`) and set
the environment variable MINIWDL__S3_PROGRESSIVE_UPLOAD__URI_PREFIX to a S3 URI prefix under which
to store the output files (e.g. "s3://my_bucket/workflow123_outputs"). The prefix should be set
uniquely for each run, to prevent different runs from overwriting each others' outputs.

Shells out to s3parcp, for which the environment must be set up to authorize upload to the
specified bucket (without explicit auth-related arguments).

Deposits into each successful task/workflow run directory and S3 folder, an additional file
outputs.s3.json which copies outputs.json replacing local file paths with the uploaded S3 URIs.
(The JSON printed to miniwdl standard output keeps local paths.)

Limitations:
1) All task output files are uploaded, even ones that aren't top-level workflow outputs. (We can't,
   at the moment of task completion, necessarily predict which files the calling workflow will
   finally output.)
2) Doesn't upload (or rewrite outputs JSON for) workflow output files that weren't generated by a
   task, e.g. outputting an input file, or a file generated by write_lines() etc. in the workflow.
   (We could handle such stragglers by uploading them at workflow completion; it just hasn't been
   needed yet.)
"""

import os
import subprocess
import threading
import json
import WDL
from WDL._util import StructuredLogMessage as _

_uploaded_files = {}
_uploaded_files_lock = threading.Lock()


def task(cfg, logger, run_id, run_dir, task, **recv):
    """
    on completion of any task, upload its output files to S3, and record the S3 URI corresponding
    to each local file (keyed by inode) in _uploaded_files
    """
    logger = logger.getChild("s3_progressive_upload")

    # ignore inputs
    recv = yield recv
    # ignore command/runtime/container
    recv = yield recv

    def upload_file(abs_fn, s3uri):
        s3cp(logger, abs_fn, s3uri)
        # record in _uploaded_files (keyed by inode, so that it can be found from any
        # symlink or hardlink)
        with _uploaded_files_lock:
            _uploaded_files[inode(abs_fn)] = s3uri
        logger.info(_("task output uploaded", file=abs_fn, uri=s3uri))

    if not cfg.has_option("s3_progressive_upload", "uri_prefix"):
        logger.debug("skipping because MINIWDL__S3_PROGRESSIVE_UPLOAD__URI_PREFIX is unset")
    elif not run_id[-1].startswith("download-"):
        s3prefix = cfg["s3_progressive_upload"]["uri_prefix"]
        assert s3prefix.startswith("s3://"), "MINIWDL__S3_PROGRESSIVE_UPLOAD__URI_PREFIX invalid"

        # for each file under out
        def _raise(ex):
            raise ex

        links_dir = os.path.join(run_dir, "out")
        for output in os.listdir(links_dir):
            abs_output = os.path.join(links_dir, output)
            assert os.path.isdir(abs_output)
            output_contents = [os.path.join(abs_output, fn) for fn in os.listdir(abs_output) if not fn.startswith(".")]
            assert output_contents
            if len(output_contents) == 1 and os.path.isdir(output_contents[0]) and os.path.islink(output_contents[0]):
                # directory output
                _uploaded_files[inode(output_contents[0])] = os.path.join(s3prefix, output) + "/"
                for (dn, subdirs, files) in os.walk(output_contents[0], onerror=_raise):
                    assert dn == output_contents[0] or dn.startswith(output_contents[0] + "/"), dn
                    for fn in files:
                        abs_fn = os.path.join(dn, fn)
                        s3uri = os.path.join(s3prefix, os.path.relpath(abs_fn, abs_output))
                        upload_file(abs_fn, s3uri)
            elif len(output_contents) == 1 and os.path.isfile(output_contents[0]):
                # file output
                basename = os.path.basename(output_contents[0])
                abs_fn = os.path.join(abs_output, basename)
                s3uri = os.path.join(s3prefix, basename)
                upload_file(abs_fn, s3uri)
            else:
                # file array output
                assert all(os.path.basename(abs_fn).isdigit() for abs_fn in output_contents), output_contents
                for index_dir in output_contents:
                    fns = [fn for fn in os.listdir(index_dir) if not fn.startswith(".")]
                    assert len(fns) == 1
                    abs_fn = os.path.join(index_dir, fns[0])
                    s3uri = os.path.join(s3prefix, fns[0])
                    upload_file(abs_fn, s3uri)

        # write outputs_s3.json using _uploaded_files
        write_outputs_s3_json(
            logger, recv["outputs"], run_dir, os.path.join(s3prefix, *run_id[1:]), task.name
        )

    yield recv


def workflow(cfg, logger, run_id, run_dir, workflow, **recv):
    """
    on workflow completion, add a file outputs.s3.json to the run directory, which is outputs.json
    with local filenames rewritten to the uploaded S3 URIs (as previously recorded on completion of
    each task).
    """
    logger = logger.getChild("s3_progressive_upload")

    # ignore inputs
    recv = yield recv

    if cfg.has_option("s3_progressive_upload", "uri_prefix"):
        # write outputs.s3.json using _uploaded_files
        write_outputs_s3_json(
            logger,
            recv["outputs"],
            run_dir,
            os.path.join(cfg["s3_progressive_upload"]["uri_prefix"], *run_id[1:]),
            workflow.name,
        )

    yield recv


def write_outputs_s3_json(logger, outputs, run_dir, s3prefix, namespace):
    # rewrite uploaded files to their S3 URIs
    def rewriter(fd):
        try:
            return _uploaded_files[inode(fd.value)]
        except Exception:
            logger.warning(
                _(
                    "output file or directory wasn't uploaded to S3; keeping local path in outputs.s3.json",
                    path=fd.value,
                )
            )
            return fn

    with _uploaded_files_lock:
        outputs_s3 = WDL.Value.rewrite_env_paths(outputs, rewriter)

    # get json dict of rewritten outputs
    outputs_s3_json = WDL.values_to_json(outputs_s3, namespace=namespace)

    # write to outputs.s3.json
    fn = os.path.join(run_dir, "outputs.s3.json")
    with open(fn, "w") as outfile:
        json.dump(outputs_s3_json, outfile, indent=2)
        outfile.write("\n")
    s3cp(logger, fn, os.environ.get("WDL_OUTPUT_URI", os.path.join(s3prefix, "outputs.s3.json")))


_s3parcp_lock = threading.Lock()


def s3cp(logger, fn, s3uri):
    with _s3parcp_lock:
        cmd = ["s3parcp", fn, s3uri]
        logger.debug(" ".join(cmd))
        rslt = subprocess.run(cmd, stderr=subprocess.PIPE)
        if rslt.returncode != 0:
            logger.error(
                _(
                    "failed uploading output file",
                    cmd=" ".join(cmd),
                    exit_status=rslt.returncode,
                    stderr=rslt.stderr.decode("utf-8"),
                )
            )
            raise WDL.Error.RuntimeError("failed: " + " ".join(cmd))


def inode(link):
    st = os.stat(os.path.realpath(link))
    return (st.st_dev, st.st_ino)
